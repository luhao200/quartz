---
title: 作用域
date: 2024-04-16 22:44:26
tags: 
---

作用域
2023年7月18日
9:19

变量其实只不过是程序可操作的存储区的名称。
C语言经过编译之后将内存分为以下几个区域：
（1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。

（2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。

（3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。

（4）文字常量区：存放常量字符串。程序结束后由系统释放。

（5）程序代码区：存放程序的二进制代码。
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 71%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>作用域</th>
<th>分配内存空间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>全局变量</td>
<td><p>全局作用域，</p>
<p>只需在一个源文件中定义，就可以作用于<mark>所有的源文件</mark>。</p>
<p>其他不包含全局变量定义的源文件需要用<mark>extern</mark> 关键字再次<mark>声明</mark>这个全局变量。</p>
<p>使用 extern 关键字时，<mark>不会</mark>为变量<mark>分配</mark>任何<mark>存储空间</mark>，而只是指示编译器该变量在其他文件中定义。</p></td>
<td><p>静态存储区</p>
<p>全局存储区</p></td>
</tr>
<tr class="even">
<td><p>静态全局变量</p>
<p>static</p></td>
<td><p>全局作用域，</p>
<p>与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即<mark>具有文件作用域</mark>。</p>
<p>这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p></td>
<td><p>静态存储区</p>
<p>全局存储区</p></td>
</tr>
<tr class="odd">
<td><p>静态局部变量</p>
<p>static</p></td>
<td><p>局部作用域，</p>
<p>只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。</p>
<p>它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p></td>
<td><p>静态存储区</p>
<p>全局存储区</p></td>
</tr>
<tr class="even">
<td>局部变量</td>
<td><p>局部作用域，</p>
<p>它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p></td>
<td>栈</td>
</tr>
</tbody>
</table>
注意
在==函数内==，如果两个名字相同，会==使用局部变量值==，全局变量不会被使用。

若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；

若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；

设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；

如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带"内部存储器"功能的的函数)

函数中必须要使用static变量情况:比如当某==函数的返回值为指针类型==时，则必须是==static的局部变量的地址作为返回值==，若为auto类型，则返回为错指针。
初始化局部变量和全局变量
当==局部变量被定义时，系统不会对其初始化==，您必须自行对其初始化。

定义==全局变量时，系统会自动对其初始化==：

| 数据类型 | 初始化默认值 |
|----------|--------------|
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

数组、结构体、联合等复合类型的变量：==它们的元素或成员将按照相应的规则进行默认初始化==，这可能包括对元素递归应用默认规则。

==正确地初始化变量==是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，

因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。
C 中的变量声明
1、一种是需要==建立==存储空间的。例如：==int a== 在声明的时候就已经建立了存储空间。

2、另一种是==不需要==建立存储空间的，通过使用==extern关键字声明变量名而不定义==它。

例如：==extern int a== 其中变量 a 可以在别的文件中定义的。

除非有extern关键字，否则都是变量的定义。

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。

addtwonum.c 文件代码：

\#include \<stdio.h\>

/\*外部变量声明\*/

extern int x ;

extern int y ;

int addtwonum()

{

return x+y;

}

test.c 文件代码：

\#include \<stdio.h\>

/\*定义两个全局变量\*/

int x=1;

int y=2;

int addtwonum();

int main(void)

{

int result;

result = addtwonum();

printf("result 为: %d\n",result);

return 0;

}

注意

extern int a; // 声明一个全局变量 a

int a; // 定义一个全局变量 a

extern int a =0; // 定义一个全局变量 a 并给初值。一旦给予赋值，一定是定义，定义才会分配存储空间

int a =0; //定义一个全局变量 a，并给初值，等于第三个

==声明之后你不能直接使用这个变量，需要定义之后才能使用。==

==定义只能出现在一处==。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而那个 ==extern int a 可以出现很多次==。

当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。
括号作用域
{

作用域

}
