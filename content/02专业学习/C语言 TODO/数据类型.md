---
title: 数据类型
date: 2024-04-16 22:44:26
tags: 
---

分类
基本数据类型

算术类型：整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。

枚举类型：

算术类型：被用来定义在程序中只能赋予其一定的离散整数值的变量。

void 类型：

类型说明符void表示没有值的数据类型，通常用于函数返回值。

派生类型：

指针类型和聚合类型：数组类型、结构体类型。

函数的类型指的是函数返回值的类型。
整数类型

| 类型           | 32位存储       | 64位存储 | 值范围                                               |
|----------------|----------------|----------|------------------------------------------------------|
| char           | 1 字节（八位） | 1 字节   | -128 到 127 或 0 到 255                              |
| short          | 2 字节         | 2 字节   | -32,768 到 32,767                                    |
| int            | 4 字节         | 4 字节   | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| long           | 4 字节         | 8 字节   | -2,147,483,648 到 2,147,483,647                      |
| long long      | 8字节          | 8字节    |                                                     |
| signed char    | 1 字节         | 1 字节   | -128 到 127                                          |
| unsigned char  | 1 字节         | 1 字节   | 0 到 255                                             |
| unsigned int   | 4 字节         | 4 字节   | 0 到 65,535 或 0 到 4,294,967,295                    |
| unsigned short | 2 字节         | 2 字节   | 0 到 65,535                                          |
| unsigned long  | 4 字节         | 8字节    | 0 到 4,294,967,295                                   |
| \*(指针变量)   | 4 字节         | 8 字节   |                                                     |

注意，==各种类型的存储大小与系统位数（具体到每一个装置）有关==，但目前通用的以64位系统为主。

==sizeof(type)==：得到某个类型或某个变量在特定平台上的准确大小

==使用新装置时可用sizeof去测试具体的位数==

printf("int 存储大小 : %lu \n", sizeof(int)); //%lu 为 32 位无符号整数
浮点类型
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 3%" />
<col style="width: 11%" />
<col style="width: 3%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
<th>精度</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4 字节</td>
<td>1.2E-38 到 3.4E+38</td>
<td><mark>6 位</mark>有效位</td>
<td><p>单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。</p>
<p>![image1](resources/91b06a8a8eed4fa291315d9d97d18b4d.png)</p></td>
</tr>
<tr class="even">
<td>double</td>
<td>8 字节</td>
<td>2.3E-308 到 1.7E+308</td>
<td><mark>15 位</mark>有效位</td>
<td><p>双精度浮点值。双精度是1位符号，11位指数，52位小数。</p>
<p>![image2](resources/bfb4fdb8ecf04a9aa3cacfe337511425.png)</p></td>
</tr>
<tr class="odd">
<td>long double</td>
<td>16 字节</td>
<td>3.4E-4932 到 1.1E+4932</td>
<td>19 位有效位</td>
<td></td>
</tr>
</tbody>
</table>
void 类型
函数返回为空

C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);

函数参数为空

C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);

指针指向 void==万能指针==

==类型为 void \* 的指针代表对象的地址，而不是类型==。例如，内存分配函数 void \*malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。
类型转换
隐式类型转换：

隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。

它通常是将一种==较小的类型自动转换为较大的类型==，例如，将int类型转换为long类型或float类型转换为double类型。

隐式类型转换也可能会==导致数据精度丢失或数据截断==。

实例

int i = 10;

float f = 3.14;

double d = i + f; // 隐式将int类型转换为double类型

显式类型转换：

显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。

强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会==导致数据丢失或截断==。

实例

double d = 3.14159;

int i = (int)d; // 显式将double类型转换为int类型
基本类型书写
整数

默认为10进制 ，10 ，20。

==以0开头为8进制==，045，021。

==以0b开头为2进制==，0b11101101。

==以0x开头为16进制==，0x21458adf。

小数

单精度常量：2.3f 。

双精度常量：2.3，==默认为双精度==。

字符型常量

用英文单引号括起来，只保存一个字符'a'、'b' 、'\*' ，还有转义字符 '\n' 、'\t'。

字符串常量

用英文的双引号引起来 可以保存多个字符："abc"。
C99
提供了 \_Bool 型，布尔类型可以声明为 \_Bool flag。

\_Bool 依然仍是整数类型，但与一般整型不同的是，\_Bool 变量只能赋值为 0 或 1，非 0 的值都会被存储为 1。

C99还提供了一个头文件 \<stdbool.h\> 定义了 bool 代表 \_Bool，true 代表 1，false 代表 0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。

//导入 stdbool.h 来使用布尔类型

\#include \<stdbool.h\>

\#include \<stdio.h\>

//计算n!,n的值在main中定义

int main(void)

{

int n = 10; //计算叠乘数

int sum = 1; //用来存放叠乘的结果

bool flag = false; //叠乘标记

int num = n; //循环次数

while( !flag )

{

sum = sum \* (num--);

//当num=1时结束循环

if( num == 1)

{

flag = true;

}

}

printf ("%d的叠乘值为 %d \n", n, sum);

return 0;

}
register 存储类
用于定义存储在==寄存器中而不是 RAM== 中的==局部变量==。不能直接取地址

变量的最大尺寸等于寄存器的大小（==通常是一个字==），且==不能==对它应用一元的 =='&'== 运算符（因为它==没有内存位置==）

变量的访问速度更快，可用于在需要==频繁访问的变量==上

它意味着变量==可能==存储在寄存器中，取决于硬件和实现的限制
