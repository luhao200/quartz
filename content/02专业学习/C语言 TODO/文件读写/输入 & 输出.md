---
title: 输入 & 输出
date: 2024-04-16 22:44:26
tags: 
---

标准文件

| 标准文件 | 文件指针 | 设备     |
|----------|----------|----------|
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

C 语言中的 I/O (输入/输出) 通常使用 ==printf() 和 scanf()== 两个函数。

scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。
getchar() & putchar() 函数
int getchar(void) 函数从屏幕==读取下一个可用的字符==，并把它==返回为一个整数==。这个函数在同一个时间内只会读取一个==单一==的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

int putchar(int c) 函数把==字符输出到屏幕上==，并==返回相同的字符==。这个函数在同一个时间内只会输出一个==单一==的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。
gets() & puts() 函数
char \*gets(char \*s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个==终止符或 EOF==。

读取的==换行符==被==转换为null值==，做为字符数组的最后一个字符，来结束字符串。

注意：gets函数由于没有指定输入字符大小，所以会==无限读取==，一旦==输入的字符大于数组长度==，就会发生内存越界，从而造成程序崩溃或其他数据的错误。

int puts(const char \*s) 函数把==字符串 s== 和一个尾随的==换行符==写入到 stdout。

linux系统下需要这样编译：==不支持 gets 与 puts, 需要用 fgets 和 fputs==。

char c\[100\];

printf("Enter a value:");

fgets( c,100,stdin );

printf("\nyou entered:");

fputs( c,stdout );

输出结果为：

Enter a value**:**runoob

you entered**:**runoob
scanf() 和 printf() 函数
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>格式字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><blockquote>
<p>a, A</p>
</blockquote></td>
<td><p>以十六进制形式输出浮点数(C99 新增)。</p>
<p>实例printf("pi=%a\n", 3.14);输出pi=0x1.91eb86p+1</p></td>
</tr>
<tr class="even">
<td><blockquote>
<p>d</p>
</blockquote></td>
<td>以十进制形式输出带符号整数(正数不输出符号)</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>o</p>
</blockquote></td>
<td>以八进制形式输出无符号整数(不输出前缀0)</td>
</tr>
<tr class="even">
<td><blockquote>
<p>x,X</p>
</blockquote></td>
<td>以十六进制形式输出无符号整数(不输出前缀Ox)</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>u</p>
</blockquote></td>
<td>以十进制形式输出<mark>无符号</mark>整数</td>
</tr>
<tr class="even">
<td><blockquote>
<p>f</p>
</blockquote></td>
<td>以小数形式输出单精度实数</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>lf</p>
</blockquote></td>
<td>双精度实数</td>
</tr>
<tr class="even">
<td><blockquote>
<p>e,E</p>
</blockquote></td>
<td>以指数形式输出单、双精度实数</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>c</p>
</blockquote></td>
<td>输出单个字符</td>
</tr>
<tr class="even">
<td><blockquote>
<p>s</p>
</blockquote></td>
<td>输出字符串</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>p</p>
</blockquote></td>
<td>输出指针地址</td>
</tr>
<tr class="even">
<td><blockquote>
<p>lu</p>
</blockquote></td>
<td>32位无符号整数</td>
</tr>
<tr class="odd">
<td><blockquote>
<p>llu</p>
</blockquote></td>
<td>64位无符号整数</td>
</tr>
<tr class="even">
<td><blockquote>
<p>g,G</p>
</blockquote></td>
<td>以%f或%e中较短的输出宽度输出单、双精度实数</td>
</tr>
</tbody>
</table>
在进行输出时，若要用到用来输出实数的 ==f 格式符==（以小数形式输出），有以下几种用法：

1、基本型，用 %f

不指定输出类型的长度，用系统根据情况决定，一般是实数中的==整数部分全部输出，小数部分输出六位==。例：

double a=1.0;

printf("%f\n",a/3);

运行结果：0.333333

2、指定数据宽度和小数位数，用 ==%m.nf==

例：将上个程序的双精度变量 a 输出 15 位小数，用 %20.15f 的格式声明，指定==输出的数据占 20 列，其中包括 15 位小数==。改动上面程序如下：

double a=1.0;

printf("%20.15f\n",a/3);

运行结果： 0.333333333333333

注意在 0 的前面有 3 个空格，且双精度数只保证 15 位有效数字的准确性。

3、输出的数据相==左对齐==，用 %-m.nf

在 m.n 前加一个负号，其作用与 %m.nf 形式作用基本相同，但当数据长度不长过 m 时，数据向左靠，右端补空格。

| int fprintf(FILE \*stream, const char \*format, ...)   | 发送格式化输出到流 stream 中。    |
|--------------------------------------------------------|-----------------------------------|
| int sprintf(char \*str, const char \*format, ...)      | 发送格式化输出到字符串。          |
| int printf(const char \*format, ...)                   | 发送格式化输出到标准输出 stdout。 |
| int fscanf(FILE \*stream, const char \*format, ...)    | 从流 stream 读取格式化输入。      |
| int sscanf(const char \*str, const char \*format, ...) | 从字符串读取格式化输入。          |
| int scanf(const char \*format, ...)                    | 从标准输入 stdin 读取格式化输入。 |

Windows、Unix、Mac不同操作系统的换行问题 回车符\r和换行符\n
一、概念：

换行符‘\n’和回车符‘\r’

（1）换行符就是另起一行 --- '\n' 10 换行（newline）

（2）回车符就是回到一行的开头 --- '\r' 13 回车（return）

所以我们平时编写文件的回车符应该确切来说叫做回车换行符

CR: 回车(Carriage Return) \rLF: 换行(Line Feed) \n

二、应用：

（1）在微软的MS-DOS和Windows中，使用“回车CR('\r')”和“换行LF('\n')”两个字符作为换行符;

（2）Windows系统里面，每行结尾是 回车+换行(CR+LF)，即“\r\n”；

（3）Unix系统里，每行结尾只有 换行LF，即“\n”；

（4）Mac系统里，每行结尾只有 换行LF，即“\n”。

三、影响：

（1）一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；

（2）而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

（3）Linux保存的文件在windows上用记事本看的话会出现黑点。

四、可以相互转换：

在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。

在不同平台间使用FTP软件传送文件时, 在==ascii文本模式==传输模式下, 一些FTP客户端程序会==自动==对换行格式进行转换. 经过这种传输的文件字节数可能会发生变化。

如果你不想ftp修改原文件, 可以使用==bin模式==(二进制模式)传输文本。

一个程序在windows上运行就生成CR/LF换行格式的文本文件，而在Linux上运行就生成LF格式换行的文本文件。

实例：

While(command != 'q'){

printf("按任意键继续，输入q退出：");

getchar(); // scanf中有一个隐藏回车，会影响下一个接受字符的值获取

command = getchar();

}
正则表达式
这段代码：

int i;

char c;

scanf("%d%c", &i,&c);

这时候变量 c 中存储的往往不是你想输入的字符，而是一个空格，然后我们又会这样来写：

int i;

char c;

scanf("%d", &i);

scanf("%c", &c);

这时候，我们发现，根本没有输入字符C的机会，这是为什么？因为输入流是有缓冲区的，我们输入的字符存储在那，然后再赋值给我们的变量。我们可以这样改：

int i;

char c;

scanf("%d", &i);

while((c=getchar())==' ' \|\| c=='\n');

c = getchar();

这个办法是一直读取，读到没有空格和换行就跳出循环，但是有一个更好的解决办法；

int i;

char c;

scanf("%d%\[^' '^'\n'\]", &i, &c);

这是用==正则表达==来控制输入格式为非空格非换行。
