---
title: 多线程
date: 2024-04-16 22:44:26
tags:
  - status/todo
---

编译应==-lpthread==编译多线程程序

pthread\_self();

  返回当前线程的线程号

pthread\_t tid1

  生成pthread\_t 类型的变量：线程号1

pthread\_create(pthread\_t \*thread, const pthread\_attr\_t \*attr,void \*(\*start\_routine) (void \*), void \*arg);

  第一个参数为 pthread\_t 指针，用来保存新建线程的线程号

  第三个参数是一个函数指针，就是线程执行的函数。这个函数返回值为void\*，形参为 void\*

  第四个参数则表示为向线程处理函数传入的参数，若不传入，可用 NULL填充

  不传入

    void \*fun(void \*arg)

    {

            printf("pthread\_New = %lu\\n",(unsigned long)pthread\_self());

    }

    int ret = pthread\_create(&tid1,NULL,fun,NULL)

  传入参数

    int a = 50;

    int ret = pthread\_create(&tid1,NULL,fun1,(void \*)&a);

    if(ret != 0){

            perror("pthread\_create");

            return -1;

    }

    线程处理的回调函数中，先将万能指针 void\*转化为 int\*，再次取地址就可以获得该地址变量的值，其本质在于地址的传递。

  ==传递多个参数==

    我们可以通过结构体来进行传递，解决此问题

    struct Stu{

            int Id;

            char Name\[32\];

            float Mark;

    };

    void \*fun1(void \*arg)

    {

            struct Stu \*tmp = (struct Stu \*)arg;

            printf("%s:Id = %d Name = %s Mark = %.2f\\n",\_\_FUNCTION\_\_,tmp->Id,tmp->Name,tmp->Mark);

    }

    int main()

    {

            pthread\_t tid1,tid2;

            struct Stu stu;

            stu.Id = 10000;

            strcpy(stu.Name,"ZhangSan");

            stu.Mark = 94.6;

            int ret = pthread\_create(&tid1,NULL,fun1,(void \*)&stu);

            if(ret != 0){

                    perror("pthread\_create");

                    return -1;

            }

            printf("%s:Id = %d Name = %s Mark = %.2f\\n",\_\_FUNCTION\_\_,stu.Id,stu.Name,stu.Mark);

            sleep(1);

            return 0;

    }

线程的退出与回收

  主动退出pthread\_exit

  被动退出pthread\_cancel该函数传入一个 tid 号，会强制退出该 tid 所指向的线程，若成功执行会返回 0

  资源回收pthread\_join默认状态为阻塞状态，直到成功回收线程后才返回

  pthread\_tryjoin\_np为非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回 0，其余参数与 pthread\_join 一致

  void \*fun1(void \*arg)

  {

          static int tmp = 0;//必须要static修饰，否则pthread\_join无法获取到正确值

          //int tmp = 0;

          tmp = \*(int \*)arg;

          tmp+=100;

          printf("%s:Addr = %p tmp = %d\\n",\_\_FUNCTION\_\_,&tmp,tmp);

          pthread\_exit((void \*)&tmp);

  }

  int main()

  {

          pthread\_t tid1;

          int a = 50;

          void \*Tmp = NULL;

          int ret = pthread\_create(&tid1,NULL,fun1,(void \*)&a);

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          pthread\_join(tid1,&Tmp);

          printf("%s:Addr = %p Val = %d\\n",\_\_FUNCTION\_\_,Tmp,\*(int \*)Tmp);

          return 0;

  }

互斥锁 API 简述

  互斥量加锁/解锁

  int pthread\_mutex\_lock(pthread\_mutex\_t \*mutex);

  int pthread\_mutex\_unlock(pthread\_mutex\_t \*mutex);

  互斥量加锁(非阻塞方式)

  int pthread\_mutex\_trylock(pthread\_mutex\_t \*mutex);

  互斥量销毁(非阻塞方式)

  int pthread\_mutex\_destory(pthread\_mutex\_t \*mutex);

  pthread\_mutex\_t mutex;//互斥量变量 一般申请全局变量

  int Num = 0;//公共临界变量

  void \*fun1(void \*arg)

  {

          pthread\_mutex\_lock(&mutex);//加锁 若有线程获得锁，则会阻塞

          while(Num < 3){

                  Num++;

                  printf("%s:Num = %d\\n",\_\_FUNCTION\_\_,Num);

                  sleep(1);

          }

          pthread\_mutex\_unlock(&mutex);//解锁

          pthread\_exit(NULL);//线程退出 pthread\_join 会回收资源

  }

  void \*fun2(void \*arg)

  {

          pthread\_mutex\_lock(&mutex);

          while(Num > -3){

                  Num--;

                  printf("%s:Num = %d\\n",\_\_FUNCTION\_\_,Num);

                  sleep(1);

          }

          pthread\_mutex\_unlock(&mutex);

          pthread\_exit(NULL);

  }

  int main()

  {

          int ret;

          pthread\_t tid1,tid2;

          ret = pthread\_mutex\_init(&mutex,NULL);//初始化互斥量

          if(ret != 0){

                  perror("pthread\_mutex\_init");

                  return -1;

          }

          ret = pthread\_create(&tid1,NULL,fun1,NULL);

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          ret = pthread\_create(&tid2,NULL,fun2,NULL);

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          pthread\_join(tid1,NULL);//阻塞回收线程 1

          pthread\_join(tid2,NULL);

          pthread\_mutex\_destroy(&mutex);//销毁互斥量

          return 0;

  }

信号量 API 简述

  初始化信号量

  int sem\_init(sem\_t \*sem,int pshared,unsigned int value);

  第二个参数传入 0 代表线程控制，否则为进程控制；

  第三个参数表示信号量的初始值，0 代表阻塞，1 代表运行。

  信号量 P/V 操作

  int sem\_wait(sem\_t \*sem);

  int sem\_post(sem\_t \*sem);

  sem\_wait 函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行“sem-1”的操作。所谓的“sem-1”是与上述初始化函数中第三个参数值一致，成功执行会返回 0。

  sem\_post 函数会释放指定信号量的资源，执行“sem+1”操作。

  信号量申请(非阻塞方式)

  int sem\_trywait(sem\_t \*sem);

  信号量销毁

  int sem\_destory(sem\_t \*sem);

  sem\_t sem1,sem2,sem3;//申请的三个信号量变量

  void \*fun1(void \*arg)

  {

          sem\_wait(&sem1);//因sem1本身有资源，所以不被阻塞 获取后sem1-1 下次会会阻塞

          printf("%s:Pthread Come!\\n",\_\_FUNCTION\_\_);

          sem\_post(&sem2);// 使得sem2获取到资源

          pthread\_exit(NULL);

  }

  void \*fun2(void \*arg)

  {

          sem\_wait(&sem2);//因sem2在初始化时无资源会被阻塞，直至14行代码执行 不被阻塞 sem2-1 下次会阻塞

          printf("%s:Pthread Come!\\n",\_\_FUNCTION\_\_);

          sem\_post(&sem3);// 使得sem3获取到资源

          pthread\_exit(NULL);

  }

  void \*fun3(void \*arg)

  {

          sem\_wait(&sem3);//因sem3在初始化时无资源会被阻塞，直至22行代码执行 不被阻塞 sem3-1 下次会阻塞

          printf("%s:Pthread Come!\\n",\_\_FUNCTION\_\_);

          sem\_post(&sem1);// 使得sem1获取到资源

          pthread\_exit(NULL);

  }

  int main()

  {

          int ret;

          pthread\_t tid1,tid2,tid3;

          ret = sem\_init(&sem1,0,1); //初始化信号量1 并且赋予其资源

          if(ret < 0){

                  perror("sem\_init");

                  return -1;

          }

          ret = sem\_init(&sem2,0,0); //初始化信号量2 让其阻塞

          if(ret < 0){

                  perror("sem\_init");

                  return -1;

          }

          ret = sem\_init(&sem3,0,0); //初始化信号3 让其阻塞

          if(ret < 0){

                  perror("sem\_init");

                  return -1;

          }

          ret = pthread\_create(&tid1,NULL,fun1,NULL);//创建线程1

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          ret = pthread\_create(&tid2,NULL,fun2,NULL);//创建线程2

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          ret = pthread\_create(&tid3,NULL,fun3,NULL);//创建线程3

          if(ret != 0){

                  perror("pthread\_create");

                  return -1;

          }

          /\*回收线程资源\*/

          pthread\_join(tid1,NULL);

          pthread\_join(tid2,NULL);

          pthread\_join(tid3,NULL);

          /\*销毁信号量\*/

          sem\_destroy(&sem1);

          sem\_destroy(&sem2);

          sem\_destroy(&sem3);

          return 0;

  }
