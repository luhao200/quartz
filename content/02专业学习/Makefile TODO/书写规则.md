---
title: 书写规则
date: 2024-04-16 22:44:26
tags: 
---

在规则中使用通配符
make支持三个通配符： \* ， ? 和 ~ 。这是和Unix的B-Shell是相同的。

波浪号（ ~ ）字符在文件名中也有比较特殊的用途。

如果是 ~/test ，这就表示当前用户的 \$HOME 目录下的test目录。

而 ~hchen/test 则表示用户hchen的宿主目录下的test 目录。

通配符代替了你一系列的文件，如 \*.c 表示所有后缀为c的文件。
文件搜索
如果没有指明==VPATH这个变量==，make只会在当前的目录中去找寻依赖文件和目标文件。

如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。

VPATH = src:../headers

另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，

它可以指定不同的文件在不同的搜索目录中。它的使用方法有三种：

vpath \<pattern\> \<directories\>

为符合模式\<pattern\>的文件指定搜索目录\<directories\>。

vpath \<pattern\>

清除符合模式\<pattern\>的文件的搜索目录。

vpath

清除所有已被设置好了的文件搜索目录。

例如：

vpath %.h ../headers

该语句表示，要求make在“../headers”目录下搜索所有以 .h 结尾的文件。

我们可以连续地使用vpath语句，以指定不同搜索策略。

如果连续的vpath语句中出现了相同的\<pattern\> ，或是被重复了的\<pattern\>，那么，make会按照vpath语句的先后顺序来执行搜索。如：

vpath %.c foo

vpath % blish

vpath %.c bar

其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。

vpath %.c foo:bar

vpath % blish

而上面的语句则表示 .c 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。
伪目标
“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make==无法生成它的依赖关系和决定它是否要执行==。

为了避免和文件重名的情况，我们可以使用一个特殊的标记==“.PHONY”来显式==地指明一个目标是“伪目标”

只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“==make clean==”

.PHONY : clean

clean :

rm \*.o temp

伪目标==一般没有依赖==的文件。但是，我们也可以为伪目标指定所依赖的文件。==伪目标同样可以作为“默认目标”==，只要将其放在第一个。

实例：

all : prog1 prog2 prog3

.PHONY : all

prog1 : prog1.o utils.o

cc -o prog1 prog1.o utils.o

prog2 : prog2.o

cc -o prog2 prog2.o

prog3 : prog3.o sort.o utils.o

cc -o prog3 prog3.o sort.o utils.o

==伪目标同样也可成为依赖==。

实例：

.PHONY : cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff

rm program

cleanobj :

rm \*.o

cleandiff :

rm \*.diff

这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。
多目标
静态模式
语法：

\<targets ...\> : \<target-pattern\> : \<prereq-patterns ...\>

\<commands\>

targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。

target-pattern是指明了targets的模式，也就是的目标集模式。

prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。

实例：

objects = foo.o bar.o

all: \$(objects)

\$(objects): %.o: %.c

\$(CC) -c \$(CFLAGS) \$\< -o \$@

展开后等价于下面的规则：

foo.o : foo.c

\$(CC) -c \$(CFLAGS) foo.c -o foo.o

bar.o : bar.c

\$(CC) -c \$(CFLAGS) bar.c -o bar.o
自动生成依赖性
大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系

执行下面的命令：cc -M main.c

输出是：main.o : main.c defs.h

使用GNU的C/C++编译器，用“-MM”参数，“-M”参数会把一些标准库的头文件也包含进来

GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，==\[.d\]文件中就存放对应\[.c\]文件的依赖关系==。
