---
title: 变量
date: 2024-04-16 22:44:26
tags: 
---

使用变量
像是C/C++语言中的宏一样，他代表了==一个文本字串==

命名字可以包含==字符、数字，下划线（可以是数字开头）==

但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）==大小写敏感==

传统的Makefile的变量名是全大写的命名方式，==推荐使用大小写搭配==的变量名，这样可以避免和系统的变量冲突
变量的基础
变量在声明时需要给予初值

在使用时，需要给在变量名前加上==“\$”==符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来

如果你要使用真实的“\$”字符，那么你需要用“\$\$”来表示。

变量可以使用在许多地方，如规则中的==“目标”、“依赖”、“命令”以及新的变量==中
变量中的变量
“=”

在“=”左侧是变量，右侧是变量的值

右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量==不一定非要是已定义好的值==，其也可以==使用后面定义的值==。如：

foo = \$(bar)

bar = \$(ugh)

ugh = Huh?

all:

echo \$(foo)

执行“make all”将会打出变量\$(foo)的值是“Huh?”

“:=”

x := foo

y := \$(x) bar

x := later

等价于：

y := foo bar

x := later

这种方法，==前面的变量不能使用后面的变量==，只能使用前面已定义好了的变量

“?=”

FOO ?= bar

如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做

注释符==“#”的这种特性==值得我们注意，如果我们这样定义一个变量：

dir := /foo/bar \# directory to put the frobs in

dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“\$(dir)/file”那么就错了。
变量高级用法
变量值的替换

我们可以替换变量中的共有的部分，其格式是 \$(var:a=b) 或是 \${var:a=b} ，

其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。

把变量的值再当成变量

在这个例子中，\$(x)的值是“y”，所以\$(\$(x))就是\$(y)，于是\$(a)的值就是“z”。（注意，是“x=y”，而不是“x=\$(y)”）

x = y

y = z

a := \$(\$(x))

可以使用多个变量来组成一个变量的名字，然后再取其值：

first_second = Hello

a = first

b = second

all = \$(\$a\_\$b)

这里的 \$a\_\$b 组成了“first_second”，于是， \$(all) 的值就是“Hello”。
多行变量
使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令

define指令后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。

其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。

因为命令需要以\[Tab\]键开头，所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。
目标变量
可以为某个目标设置==局部变量==，这种变量被称为“Target-specific Variable”，

它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。

语法是：

\<target ...\> : \<variable-assignment\>;

\<target ...\> : overide \<variable-assignment\>

\<variable-assignment\>;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += 或是 ?= 。

第二个语法是针对于make命令行带入的变量，或是系统环境变量。

实例：

prog : CFLAGS = -g

prog : prog.o foo.o bar.o

\$(CC) \$(CFLAGS) prog.o foo.o bar.o

prog.o : prog.c

\$(CC) \$(CFLAGS) prog.c

foo.o : foo.c

\$(CC) \$(CFLAGS) foo.c

bar.o : bar.c

\$(CC) \$(CFLAGS) bar.c

在这个示例中，不管全局的 \$(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， \$(CFLAGS) 的值都是 -g
模式变量
我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上

实例：%.o : CFLAGS = -O
