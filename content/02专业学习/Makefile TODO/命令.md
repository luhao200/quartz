---
title: 命令
date: 2024-04-16 22:44:26
tags: 
---

在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的
书写命令
每条规则中的命令和操作系统==Shell==的命令行是一致的

每条命令的开头必须以==\[Tab\]键开头==，除非，命令是紧跟在依赖规则后面的分号后的
显示命令
通常，make会把其要执行的命令行在命令执行前输出到屏幕上

用==“@”==字符在命令行前，那么，这个命令将不被make显示出来

带入==make参数“-n”或“--just-print”==，只==显示命令，但不会执行命令==，这个功能很有利于我们==调试==我们的Makefile

而==make参数“-s”或“--slient”==则是==全面禁止命令的显示==。
命令执行
如果你要让上一条命令的结果应用在下一条命令时，你应该使用==分号分隔==这两条命令。

示例一：

exec:

cd /home/hchen

pwd

示例二：

exec:

cd /home/hchen; pwd

当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”
命令出错
每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。

==命令的出错并不表示就是错误的==

例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了

忽略命令的出错

全局的办法是，给make加上==“-i”或是“--ignore-errors”参数==，Makefile中所有命令都会忽略错误。

如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。

==make的参数的是“-k”或是“--keep-going”==，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。
嵌套执行make
把不同模块或是不同功能的源文件放在不同的目录中，在每个目录中都书写一个该目录的Makefile

实例：

有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。

那么我们总控的Makefile可以这样书写：

subsystem:

cd subdir && \$(MAKE)

其等价于：

subsystem:

\$(MAKE) -C subdir

我们把这个Makefile叫做“总控Makefile”，==总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明）==，但是==不会覆盖==下层的Makefile中所定义的变量，除非==指定了“-e”参数==。

如果你要==传递变量到下级Makefile==中，那么你可以使用这样的声明：

==export \<variable ...\>==

如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：

==unexport \<variable ...\>==

如果你要==传递所有的变量==，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。

SHELL、MAKEFLAGS

这两个变量不管你是否export，其==总是要传递到下层==Makefile中，

特别是MAKEFLAGS变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFLAGS变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。

make命令中的有几个参数==并不往下传递==

“-C”,“-f”,“-h”“-o”和“-W”

如果你不想往下层传递参数，那么，你可以这样来：

subsystem:

cd subdir && \$(MAKE) MAKEFLAGS=

如果定义了环境变量MAKEFLAGS，那么你得==确信其中的选项是大家都会用到==的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果。

==“-w”或是“--print-directory”==会在make的过程中输出一些信息，让你看到目前的工作目录。

当你使用==“-C”==参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有==“-s”（“--slient”）或是“--no-print-directory”==，那么，“-w”总是失效的。
定义命令包
如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。

定义这种命令序列的语法以==“define”开始，以“endef”结束==

实例：

define run-yacc

yacc \$(firstword \$^)

mv y.tab.c \$@

Endef

“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。

在“define”和“endef”中的两行就是命令序列。

这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，

第二行的命令就是把这个文件改改名字。

使用：

foo.c : foo.y

\$(run-yacc)

要使用这个命令包，我们就好像==使用变量一样==。
