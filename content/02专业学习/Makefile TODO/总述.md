---
title: 总述
date: 2024-04-16 22:44:26
tags: 
---

程序的编译和链接
编译

把源文件编译成中间代码文件，在Windows下是 .obj 文件，UNIX下是 ==.o== 文件，即 Object File

编译时，编译器需要的是==语法==的正确，==函数与变量的声明==的正确

链接

把大量的Object File合成执行文件

链接时，主要是链接==函数和全局变量==

打包

给中间目标文件打包，在Windows下这种包叫“库文件”（Library File)，也就是 ==.lib== 文件，在UNIX下，是Archive File，也就是 .a 文件
基本格式
targets: prerequisites

command

targets：规则的目标，可以是 ==Object File==（一般称它为中间文件），也可以是==可执行文件==，还可以是一个==标签==

prerequisites：生成该target所依赖的文件和/或target

command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。

==prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行==

反斜杠（/）是==换行符==的意思。
make是如何工作的
1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件

2、如果找到，它会找==文件中的第一个目标文件==（target），并把这个文件==作为最终的目标文件==

3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。

4、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）

5、C文件和H文件是存在的，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。
让make自动推导
make看到一个\[.o\]文件，它就会自动的把\[.c\]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来
清空目标文件的规则
.PHONY意思表示clean是一个“伪目标”

clean的规则不要放在文件的开头，这就会变成make的默认目标

不成文的规矩是——“==clean从来都是放在文件的最后==”
Makefile里主要包含了五个东西
（1）显式规则

显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。

（2）隐晦规则

由于我们的 make 命名有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。

（3）变量的定义

在Makefile中我们要定义一系列的变量，==变量一般都是字符串，这个有点像C语言中的宏==，

当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。

（4）文件指示

在一个 Makefile 中引用另一个 Makefile，就像C语言中的 include 一样；

根据某些情况指定 Makefile 中的有效部分，就像C语言中的预编译 \#if 一样；

还有就是定义一个多行的命令。

（5）注释

Makefile 中==只有行注释==，和 UNIX 的 Shell 脚本一样，其注释是用==“#”字符==，这个就像 C/C++ 中的“//”一样。

如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：“\\”。
Makefile的文件名
按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件

最好使用“==Makefile==”这个文件名，这个文件名第一个字符为大写，这样有一种显目的感觉。

最好不要用“==GNUmakefile==”，这个文件是GNU的make识别的。

有另外一些make只对全小写的“makefile”文件名敏感

==使用make的“-f”和“--file”参数==，如：make -f Make.Linux或make --file Make.AIX
引用其它的Makefile
使用==include关键字==可以把别的Makefile包含进来，这很像C语言的#include

语法：include \<filename\>

filename可以是当前操作系统Shell的文件模式（可以包含路径和通配符）

如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，

如果当前目录下没有找到，那么，make还会在下面的几个目录下找：

1、如果make执行时，有==“-I”或“--include-dir”参数==，那么make就会在这个参数所指定的目录下去寻找。

2、如果目录\<prefix\>/include（一般是：==/usr/local/bin或/usr/include==）存在的话，make也会去找。

如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。

它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。
环境变量 MAKEFILES
有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。
make的工作方式
1、读入所有的Makefile。

2、读入被include的其它Makefile。

3、初始化文件中的变量。

4、推导隐晦规则，并分析所有规则。

5、为所有的目标文件创建依赖关系链。

6、根据依赖关系，决定哪些目标要重新生成。

7、执行生成命令。
