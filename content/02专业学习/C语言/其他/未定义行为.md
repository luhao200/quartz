---
date: 2024-05-09
tags:
  - pf/C语言
  - status/done
  - import/pf
url: https://www.runoob.com/cprogramming/undefined-behavior.html
---

在 C 语言中，**"undefined behavior"（未定义行为）** 是指程序的行为在 C 语言标准中没有明确定义，因此可以表现为任何结果。

这意味着当程序出现未定义行为时，它可能会产生不可预测的结果，包括程序崩溃、数据损坏、安全漏洞，甚至可能看起来正常运行。

### [数组](../数组.md)越界

#import/pf

当我们尝试访问数组的越界元素时，即访问数组的第0个元素之前或数组长度之后的元素时，编译器无法确定访问到的内存空间中存储的是什么内容，因此会导致未定义行为。例如：

```c
int arr[3] = {1, 2, 3};
printf("%d\n", arr[5]); // 越界访问，结果未定义
```

### 解引用空指针

当我们尝试对空指针进行解引用操作时，编译器无法确定要访问的内存空间中存储的内容，因此会导致未定义行为。例如：

```c
int *ptr = NULL;
printf("%d\n", *ptr); // 解引用空指针，结果未定义
```

### 未初始化的局部变量

当我们使用未初始化的局部变量时，其值是未定义的，因此会导致未定义行为。例如：

```c
int x;
printf("%d\n", x); // x 未初始化，结果未定义
```

### 变量不初始化

在 C 语言中，如果变量没有显式初始化，那么它的默认值将取决于该变量的类型和其所在的作用域。

对于==全局变量和静态变量==（在函数内部定义的静态变量和在函数外部定义的全局变量），它们的默认初始值为零。

以下是不同类型的变量在没有显式初始化时的默认值：

- 整型变量（int、short、long等）：默认值为0。
- 浮点型变量（float、double等）：默认值为0.0。
- 字符型变量（char）：默认值为`\0`，即空字符。
- 指针变量：默认值为NULL，表示指针不指向任何有效的内存地址。
- 数组、结构体、联合等复合类型的变量：它们的元素或成员将按照相应的规则进行默认初始化，这可能包括对元素递归应用默认规则。

需要注意的是，**局部变量（在函数内部定义的非静态变量）不会自动初始化为默认值**，它们的初始值是未定义的（包含垃圾值）。因此，在使用局部变量之前，应该显式地为其赋予一个初始值。

总结起来，C 语言中变量的默认值取决于其类型和作用域。全局变量和静态变量的默认值为 **0**，字符型变量的默认值为 `\0`，指针变量的默认值为 NULL，而局部变量没有默认值，其初始值是未定义的。

#import/pf 正确地初始化变量是一个良好的[编程习惯](其他/编程习惯.md)，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。

### 浮点数除以零

当我们尝试对浮点数进行除以零的操作时，结果是未定义的。例如：

```c
float x = 1.0;
float y = x / 0.0; // 浮点数除以零，结果未定义
```

### 整数除以零

当我们尝试对整数进行除以零的操作时，结果是未定义的。例如：

```c
int x = 10;
int y = x / 0; // 整数除以零，结果未定义
```

### 符号溢出

当整数运算导致结果超出了整数类型能表示的范围时，结果是未定义的。例如：

```c
signed char x = 127;
x = x + 1; // signed char 溢出，结果未定义
```

### 位移操作数太大

当执行位移操作时，位移的位数大于或等于操作数的位数时，结果是未定义的。例如：

```c
int x = 1;
int y = x << 32; // 位移操作数太大，结果未定义
```

### 错误的类型转换

当我们进行不安全的类型转换时，结果是未定义的。例如：

```c
int *ptr = (int *)malloc(sizeof(int));
float *fptr = (float *)ptr; // 错误的类型转换，结果未定义
```

### 内存越界

当我们向已经释放或未分配的内存写入数据时，结果是未定义的。例如：

```c
int *ptr = (int *)malloc(sizeof(int));
free(ptr);
*ptr = 10; // 内存越界，结果未定义
```

### 未定义的浮点数行为

比如比较两个 NaN（非数字）值是否相等，这是未定义的行为。例如：

```c
float x = sqrt(-1);
float y = sqrt(-1);
if (x == y) {
    printf("NaN values are equal\n");
}
```

#### 解释

在浮点数运算中，NaN（Not a Number）表示一个未定义或无法表示的值，比如从负数中取平方根。比较两个NaN值是否相等是未定义行为，因为NaN具有特殊的性质。以下是详细解释：

1. **NaN 的定义**:
    
    - NaN 是一种特殊的浮点数值，用来表示未定义或不可表示的值。
    - 常见的NaN来源包括对负数取平方根（如`sqrt(-1)`）、0除以0等。
2. **NaN 的比较规则**:
    
    - 根据IEEE 754浮点数标准，NaN与任何值（包括它自己）的比较结果都是`false`。
    - 这意味着`NaN == NaN`和`NaN != NaN`都是`false`。

## 浮点数常量默认是`double`，而不是`float`

- **默认类型**:
    
    - 在C语言中，当你写一个带小数点的数字常量，如`3.14`，编译器默认将其视为`double`类型。
    - 这是为了防止因为默认使用`float`类型而导致的精度损失，特别是在科学计算或涉及高精度的场景中。
- **显式指定`float`类型**:
    
    - 如果你明确想要使用`float`类型，需要在数字常量的后面加上`f`或`F`，例如：`3.14f`。
    - 这样编译器就会将这个数字视为`float`类型，而不是`double`。

```c
float  Const_Pi;
Const_Pi=3.1415926f;
```

## 其他

还有一些其他未定义的行为：

- **使用未定义的浮点数特性：** 依赖于特定硬件或实现的浮点数行为，如浮点数的精度或舍入行为。
- **函数参数数量不匹配：** 调用函数时提供的参数数量与函数定义不匹配，如 `printf("%s %d", "Name")`。
- **修改字符串字面量：** 尝试修改字符串字面量的内容，如 `char *str = "Hello"`; `str[0] = 'h'`;。
- **使用未定义的程序状态：** 依赖于未定义的程序状态，如全局变量的初始值。
- **违反严格的语法规则：** 违反 C 语言的严格语法规则，如使用未声明的标识符。
- **多线程中的竞态条件：** 在多线程环境中，未同步的共享资源访问可能导致未定义行为。
- **使用未定义的标准库函数行为：** 某些标准库函数在特定条件下的行为可能是未定义的，如 fscanf() 在未匹配到任何输入时的行为。

这些都是在编程过程中需要避免的情况，因为它们可能导致程序在不同的环境下产生不确定的行为，从而使代码不可移植并可能导致程序出现错误。

## 如何规避

为了避免未定义行为，开发过程我们需要：

- **仔细阅读和遵守 C 语言标准**：了解哪些操作可能导致未定义行为，并避免这些操作。
- **使用静态分析工具**：这些工具可以帮助检测潜在的未定义行为。
- **进行彻底的测试**：测试程序的不同执行路径，以确保程序在各种情况下都能正确运行。
- **避免依赖未定义行为**：不要假设未定义行为会产生特定的结果。
- **使用安全的函数和库**：使用标准库提供的、定义良好的函数，避免使用可能导致未定义行为的非标准或不安全的函数。

未定义行为是 C 语言中一个复杂且危险的概念，它要求开发人员对 C 语言的规则有深入的理解，并采取适当的措施来避免它。通过遵循最佳实践和使用适当的工具，可以最大限度地减少未定义行为的风险，从而提高程序的可靠性和安全性。
